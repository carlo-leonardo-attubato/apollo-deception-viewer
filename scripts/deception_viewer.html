<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
<title>Catch Llama Lying</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
<style>
:root {
  --pivotal-blue: #3A82B5;
  --pivotal-blue-light: #D5E5F2;
  --pivotal-orange: #F15F22;
  --pivotal-orange-light: #FADFD3;
  --pivotal-gray: #4C4D4F;
  --pivotal-night: #161616;
  --pivotal-light-gray: #E0E0E0;
}
body {
  font-family: 'Poppins', sans-serif;
  margin: 0;
  padding: 20px;
  color: var(--pivotal-night);
  background-color: white;
  line-height: 1.6;
}
.container {
  max-width: 1200px;
  margin: 0 auto;
}
header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  border-bottom: 1px solid var(--pivotal-light-gray);
  padding-bottom: 10px;
}
h1, h2, h3, h4 {
  color: var(--pivotal-gray);
  margin: 0 0 10px 0;
}
h1 {
  font-size: 24px;
}
h2 {
  font-size: 20px;
}
h3 {
  font-size: 18px;
  margin-top: 15px;
}
h4 {
  font-size: 16px;
  margin-top: 10px;
}
.controls {
  display: flex;
  gap: 15px;
  align-items: center;
  background-color: var(--pivotal-light-gray);
  padding: 10px 15px;
  border-radius: 8px;
  margin-bottom: 20px;
}
select, button, input {
  padding: 8px 12px;
  border: 1px solid var(--pivotal-gray);
  border-radius: 4px;
  font-family: 'Poppins', sans-serif;
}
select {
  flex-grow: 1;
  background-color: white;
}
.probe-select {
  min-width: 150px;
  flex-grow: 0;
}
button {
  background-color: var(--pivotal-blue);
  color: white;
  border: none;
  cursor: pointer;
  transition: background-color 0.2s;
}
button:hover {
  background-color: #2e6b96;
}
.navigation {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}
.sample-info {
  background-color: var(--pivotal-light-gray);
  padding: 10px 15px;
  border-radius: 6px;
  margin-bottom: 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

#score-display {
  font-weight: 500;
  font-size: 16px;
  text-align: center;
}
.score-label {
  font-weight: 500;
}
.honest-score {
  color: var(--pivotal-blue);
}
.deceptive-score {
  color: var(--pivotal-orange);
}
.section-header {
  border-bottom: 1px solid var(--pivotal-light-gray);
  padding-bottom: 8px;
  margin: 25px 0 15px 0;
}
.colored-tokens {
  display: flex;
  flex-wrap: wrap;
  white-space: pre-wrap;
}
.token {
  display: inline-block;
  color: black;
  line-height: 1.3em;
  padding: 3px 0;
  margin-left: -1px;
  margin-bottom: 1px;
  border: 1px solid #eee;
  position: relative;
  font-family: monospace;
  white-space: pre-wrap;
}
.message-container {
  position: relative;
  margin-bottom: 10px;
  padding-left: 30px;
}
.message-emoji {
  position: absolute;
  left: 0;
  top: 0;
  font-size: 20px;
}
.token br {
  display: block;
  content: "";
  margin-top: 5px;
}
.token:hover::after {
  content: attr(data-score);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background-color: var(--pivotal-night);
  color: white;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  z-index: 10;
}
.header-token {
  color: #888 !important;
  font-style: italic;
}
.controls-row {
  display: flex;
  align-items: center;
  gap: 15px;
  margin-bottom: 15px;
}
.checkbox-control {
  display: flex;
  align-items: center;
  gap: 8px;
}
.checkbox-input {
  width: 16px;
  height: 16px;
}
.role-break {
  width: 100%;
  height: 10px;
  display: block;
}
.role-break.code-break {
  height: 3px;
  margin: 2px 0;
}
.token-line-break {
  display: block;
  margin: 3px 0;
  height: 0;
}
.token-break {
  display: block;
  height: 1.5em;
  width: 100%;
  clear: both;
}
.code-block {
  font-family: monospace;
  white-space: pre-wrap;
  background-color: #f5f5f5;
  border-radius: 4px;
  padding: 1em;
  margin: 0.5em 0;
  overflow-x: auto;
  tab-size: 4;
}
.code-line {
  display: block;
  width: 100%;
  min-height: 1.2em;
}
.dashboard-section {
  margin-bottom: 25px;
}
.stats-grid {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 15px;
  margin-bottom: 20px;
  background-color: #f9f9f9;
  border-radius: 6px;
  padding: 15px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
@media (max-width: 768px) {
  .stats-grid {
    grid-template-columns: repeat(3, 1fr);
  }
}
@media (max-width: 480px) {
  .stats-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}
.stat-item {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  padding: 8px;
}
.stat-label {
  font-weight: 500;
  color: var(--pivotal-gray);
  font-size: 14px;
  margin-bottom: 5px;
}
.stat-value {
  font-size: 14px;
  font-weight: 500;
}
.suspicious-region {
  padding: 12px;
  margin-bottom: 15px;
  border-radius: 6px;
  position: relative;
  overflow: hidden;
}
.suspicious-region-score {
  position: absolute;
  right: 12px;
  top: 12px;
  color: white;
  border-radius: 12px;
  padding: 2px 10px;
  font-size: 14px;
  font-weight: 500;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.token-display {
  background-color: #f8f9fa;
  border-radius: 8px;
  border: 1px solid var(--pivotal-light-gray);
  overflow-x: auto;
  padding: 15px;
  margin: 15px 0;
  font-family: monospace;
  line-height: 1.5;
  tab-size: 4;
  display: block;
}
.accordion {
  margin-top: 20px;
}
.accordion-item {
  margin-bottom: 10px;
  border: 1px solid var(--pivotal-light-gray);
  border-radius: 6px;
  overflow: hidden;
}
.accordion-header {
  padding: 12px 15px;
  background-color: #f8f9fa;
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  user-select: none;
}
.accordion-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}
.accordion-content.open {
  max-height: 2000px;
  padding: 15px;
}
.toggle-icon {
  transition: transform 0.3s;
}
.accordion-header.active .toggle-icon {
  transform: rotate(180deg);
}
.debug-info {
  font-size: 12px;
  color: #999;
  margin-top: 20px;
  padding-top: 10px;
  border-top: 1px solid var(--pivotal-light-gray);
}
.loading {
  text-align: center;
  padding: 40px;
  font-style: italic;
  color: var(--pivotal-gray);
}
.token.token-critical {
  font-weight: bold;
}

/* Game-related styles */
.classification-controls {
  display: flex;
  justify-content: center;
  gap: 20px;
  margin: 20px 0;
}

.classify-btn {
  padding: 12px 24px;
  font-size: 18px;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  transition: transform 0.2s;
  min-width: 120px;
}

.classify-btn:hover {
  transform: scale(1.05);
}

.classify-btn.honest {
  background-color: var(--pivotal-blue);
  color: white;
}

.classify-btn.deceptive {
  background-color: var(--pivotal-orange);
  color: white;
}

.classification-controls.classified {
  display: none;
}

.feedback-text {
  text-align: center;
  font-size: 18px;
  font-weight: 500;
  margin: 20px 0;
  line-height: 1.4;
}

.feedback-text.honest {
  color: var(--pivotal-blue);
}

.feedback-text.deceptive {
  color: var(--pivotal-orange);
}

.reset-btn {
  background-color: var(--pivotal-gray);
  color: white;
}

.follow-up-conversation {
  padding: 10px;
}

.follow-up-message {
  display: flex;
  margin-bottom: 15px;
  position: relative;
}

.follow-up-message .message-emoji {
  font-size: 20px;
  position: absolute;
  left: 0;
  top: 0;
}

.follow-up-message .message-content {
  flex: 1;
  margin-left: 30px;
  background-color: #f5f5f5;
  border-radius: 8px;
  padding: 12px;
  white-space: pre-wrap;
}

.follow-up-message.user-message .message-content {
  background-color: var(--pivotal-blue-light);
}

.follow-up-message.assistant-message .message-content {
  background-color: var(--pivotal-light-gray);
}

.high-score {
  border-left: 4px solid var(--pivotal-orange);
}

.medium-score {
  border-left: 4px solid #FFA500;
}

.low-score {
  border-left: 4px solid var(--pivotal-blue);
}

.follow-up-item {
  margin-bottom: 10px;
  border-radius: 6px;
  overflow: hidden;
  border: 1px solid var(--pivotal-light-gray);
}

.follow-up-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 15px;
  background-color: #f8f9fa;
  cursor: pointer;
}

.follow-up-title {
  font-weight: 500;
}

.follow-up-toggle {
  transition: transform 0.3s;
}

.follow-up-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>Catch Llama Lying</h1>
    <div>
      <span class="sample-counter">Sample: <span id="current-sample">0</span> / <span id="total-samples">0</span></span>
    </div>
  </header>

  <div class="navigation">
    <button id="prev-button">&larr; Previous</button>
    <button id="reset-button" class="reset-btn">Reset Game</button>
    <button id="next-button">Next &rarr;</button>
  </div>

  <div class="controls">
    <select id="dataset-select">
      <option value="" disabled>Select a dataset</option>
      <option value="alpaca">Alpaca</option>
      <option value="ai_liar__original_without_answers" selected>AI Liar (Original)</option>
      <option value="ai_liar__deception_dilution_100">AI Liar (Deception Dilution)</option>
      <option value="backdoors_onpolicy_redact">Backdoors (On-Policy Redact)</option>
      <option value="backdoors_w_help">Backdoors (Explicit)</option>
      <option value="insider_trading__upscale">Insider Trading</option>
      <option value="sandbagging_v2__wmdp_mmlu">Sandbagging</option>
      <option value="scored_roleplaying__plain_deception_no">Roleplaying</option>
    </select>
    <select id="probe-select" class="probe-select">
      <option value="pairs_probe" selected>Pairs Probe</option>
      <option value="rp_probe">RP Probe</option>
    </select>
    <div>
      <input type="number" id="sample-jump" min="1" placeholder="Jump to..." style="width: 100px;">
      <button id="jump-button">Go</button>
    </div>
  </div>

  <div class="sample-info">
    <div>
      <strong id="dataset-name-display">No dataset selected</strong> sample <span id="sample-id">-</span>
    </div>
    <div id="score-display" style="flex: 1; text-align: center;">
      Score: <span id="avg-score" class="score-label">-</span>
    </div>
    <div>
      <span id="game-score-display">Game: <span id="game-score">0</span> / <span id="total-attempts">0</span></span>
      <span id="sample-label" style="display: none;">-</span>
    </div>
  </div>

  <!-- Add classification buttons -->
  <div id="classification-buttons" class="classification-controls">
    <button id="honest-button" class="classify-btn honest">Honest</button>
    <button id="deceptive-button" class="classify-btn deceptive">Deceptive</button>
  </div>

  <!-- Main Content Area -->
  <!-- 1. Conversation Section -->
  <h2 class="section-header">Conversation</h2>
  <div class="controls-row">
    <div class="checkbox-control">
      <input class="checkbox-input" type="checkbox" id="maskToggle" checked>
      <label for="maskToggle">Show scores for assistant tokens only</label>
    </div>
    <div class="checkbox-control">
      <input class="checkbox-input" type="checkbox" id="showHiddenToggle">
      <label for="showHiddenToggle">Reveal hidden tokens</label>
    </div>
    <div class="checkbox-control">
      <input class="checkbox-input" type="checkbox" id="showCriticalToggle" checked>
      <label for="showCriticalToggle">Bold critical tokens</label>
    </div>
  </div>
  <div id="tokens-display" class="token-display"></div>

  <!-- 2. Analysis Dashboard Section -->
  <h2 class="section-header">Analysis Dashboard</h2>
  <div class="dashboard-section">
    <h3>Statistical Summary of Public Assistant Tokens</h3>
    <div class="stats-grid">
      <div class="stat-item">
        <div class="stat-label">Average Score</div>
        <div id="avg-deception-score" class="stat-value">-</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Median Score</div>
        <div id="median-score" class="stat-value">-</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Peak Score</div>
        <div id="peak-score" class="stat-value">-</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Critical Tokens Avg</div>
        <div id="critical-tokens-avg" class="stat-value">-</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Tokens > 0</div>
        <div id="tokens-above-zero" class="stat-value">-</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Response Tokens</div>
        <div id="total-tokens" class="stat-value">-</div>
      </div>
    </div>

    <!-- Critical Claim Section -->
    <h3>Critical Claim</h3>
    <div id="critical-claim-section">
      <p>No critical claim available for this sample.</p>
    </div>

    <!-- Suspicious Regions -->
    <h3>Most Deceptive Regions</h3>
    <div id="suspicious-regions">
      <!-- Will be filled dynamically -->
    </div>
  </div>

  <!-- 3. Cross-examination Section -->
  <h2 class="section-header">Cross-examinations</h2>
  <div id="follow-ups-container" class="accordion">
    <!-- Will be filled dynamically with accordion items -->
  </div>
  
  <div id="debug-info" class="debug-info"></div>
</div>

<script>
// Global variables
let currentDataset = null;
let samples = [];
let currentSampleIndex = 0;
let currentProbe = 'pairs_probe';
let assistantOnly = true;
let showHiddenTokens = false;
let showCritical = true;
let criticalIndices = [];
let gameScore = 0;
let totalAttempts = 0;
let classifiedSamples = new Set();

// Elements
const datasetSelect = document.getElementById('dataset-select');
const probeSelect = document.getElementById('probe-select');
const tokensDisplay = document.getElementById('tokens-display');
const prevButton = document.getElementById('prev-button');
const nextButton = document.getElementById('next-button');
const jumpButton = document.getElementById('jump-button');
const sampleJump = document.getElementById('sample-jump');
const currentSampleSpan = document.getElementById('current-sample');
const totalSamplesSpan = document.getElementById('total-samples');
const datasetNameDisplay = document.getElementById('dataset-name-display');
const sampleIdSpan = document.getElementById('sample-id');
const sampleLabelSpan = document.getElementById('sample-label');
const gameScoreDisplay = document.getElementById('game-score');
const totalAttemptsDisplay = document.getElementById('total-attempts');
const avgScoreSpan = document.getElementById('avg-score');
const resetButton = document.getElementById('reset-button');
const classificationButtons = document.getElementById('classification-buttons');
const honestButton = document.getElementById('honest-button');
const deceptiveButton = document.getElementById('deceptive-button');
const maskToggle = document.getElementById('maskToggle');
const showHiddenToggle = document.getElementById('showHiddenToggle');
const showCriticalToggle = document.getElementById('showCriticalToggle');
const debugInfo = document.getElementById('debug-info');
const followUpsContainer = document.getElementById('follow-ups-container');
const suspiciousRegionsDiv = document.getElementById('suspicious-regions');

// Dashboard statistics elements
const avgDeceptionScore = document.getElementById('avg-deception-score');
const medianScore = document.getElementById('median-score');
const peakScore = document.getElementById('peak-score');
const tokensAboveZeroElement = document.getElementById('tokens-above-zero');
const totalTokens = document.getElementById('total-tokens');

// Event listeners
datasetSelect.addEventListener('change', loadDataset);
probeSelect.addEventListener('change', function() {
  currentProbe = probeSelect.value;
  if (samples.length > 0) {
    displaySample(currentSampleIndex);
  }
});
prevButton.addEventListener('click', showPreviousSample);
nextButton.addEventListener('click', showNextSample);
jumpButton.addEventListener('click', jumpToSample);
sampleJump.addEventListener('keydown', function(event) {
  if (event.key === 'Enter') {
    jumpToSample();
  }
});
resetButton.addEventListener('click', resetGame);
maskToggle.addEventListener('change', function() {
  assistantOnly = this.checked;
  if (samples.length > 0) {
    displaySample(currentSampleIndex);
  }
});
showHiddenToggle.addEventListener('change', function() {
  showHiddenTokens = this.checked;
  if (samples.length > 0) {
    displaySample(currentSampleIndex);
  }
});
showCriticalToggle.addEventListener('change', function() {
  showCritical = this.checked;
  if (samples.length > 0) {
    displaySample(currentSampleIndex);
  }
});

// Add classification button event listeners
honestButton.addEventListener('click', () => handleClassification('honest'));
deceptiveButton.addEventListener('click', () => handleClassification('deceptive'));

// Load default dataset on page load
document.addEventListener('DOMContentLoaded', function() {
  // Select and load AI Liar dataset by default
  loadDataset();
});

// Functions
async function loadDataset() {
  // Get selected dataset, default to AI Liar if none selected
  const selectedDataset = datasetSelect.value || 'ai_liar__original_without_answers';
  
  tokensDisplay.innerHTML = '<div class="loading">Loading dataset...</div>';
  currentDataset = selectedDataset;
  
  // Reset classified samples when changing datasets
  classifiedSamples.clear();
  
  // Format dataset name for display
  const datasetName = selectedDataset
    .replace(/__/g, ' - ')
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
  
  datasetNameDisplay.textContent = datasetName;
  
  try {
    // Use the consolidated dataset path
    const response = await fetch(`../datasets/apollo_deception_consolidated/${selectedDataset}.jsonl`);
    if (!response.ok) {
      throw new Error(`Failed to load dataset: ${response.statusText}`);
    }
    
    const text = await response.text();
    // Split by newlines and parse each line as JSON
    samples = text.trim().split('\n')
      .map(line => {
        try {
          return JSON.parse(line);
        } catch (e) {
          console.error('Failed to parse line:', line);
          return null;
        }
      })
      .filter(sample => sample !== null);
    
    if (samples.length === 0) {
      throw new Error("No valid samples found in the dataset");
    }
    
    currentSampleIndex = 0;
    totalSamplesSpan.textContent = samples.length;
    displaySample(currentSampleIndex);
  } catch (error) {
    console.error('Error loading dataset:', error);
    tokensDisplay.innerHTML = `<div class="error">Error loading dataset: ${error.message}</div>`;
  }
}

function showPreviousSample() {
  if (currentSampleIndex > 0) {
    currentSampleIndex--;
    displaySample(currentSampleIndex);
  }
}

function showNextSample() {
  if (currentSampleIndex < samples.length - 1) {
    currentSampleIndex++;
    displaySample(currentSampleIndex);
  }
}

function jumpToSample() {
  const targetIndex = parseInt(sampleJump.value) - 1;
  if (!isNaN(targetIndex) && targetIndex >= 0 && targetIndex < samples.length) {
    currentSampleIndex = targetIndex;
    displaySample(currentSampleIndex);
  }
}

function getTokenColor(score) {
  // Define the gradient colors
  const honestColor = {r: 58, g: 130, b: 181};  // #3A82B5 - Pivotal Blue
  const deceptiveColor = {r: 241, g: 95, b: 34}; // #F15F22 - Pivotal Orange
  const neutralColor = {r: 255, g: 255, b: 255}; // White for neutral
  
  // Define the color interpolation function
  function interpolateColor(color1, color2, factor) {
    return {
      r: Math.round(color1.r + factor * (color2.r - color1.r)),
      g: Math.round(color1.g + factor * (color2.g - color1.g)),
      b: Math.round(color1.b + factor * (color2.b - color1.b))
    };
  }
  
  let resultColor;
  // Keep text color black for all tokens
  let textColor = 'black';
  let opacity = 0.55; // Increased opacity value
  
  // Map score to color using a smooth gradient
  if (score < 0) {
    // Honest score (blue)
    // Map score from -10..0 to 0..1
    const factor = Math.min(Math.abs(score) / 10, 1);
    resultColor = interpolateColor(neutralColor, honestColor, factor);
    // For very honest scores, increase opacity slightly
    if (factor > 0.7) opacity = 0.7;
  } else {
    // Deceptive score (orange)
    // Map score from 0..10 to 0..1
    const factor = Math.min(score / 10, 1);
    resultColor = interpolateColor(neutralColor, deceptiveColor, factor);
    // For very deceptive scores, increase opacity slightly
    if (factor > 0.7) opacity = 0.7;
  }
  
  return {
    bgColor: `rgba(${resultColor.r}, ${resultColor.g}, ${resultColor.b}, ${opacity})`,
    textColor: textColor
  };
}

// Analyze the conversation to determine token roles
function analyzeConversation(tokens, sample) {
  // Create arrays to track what each token is
  const tokenRoles = new Array(tokens.length).fill('unknown');
  const isHeader = new Array(tokens.length).fill(false);
  const isContent = new Array(tokens.length).fill(false);
  const isDateToken = new Array(tokens.length).fill(false); // Track date tokens
  const isPublic = new Array(tokens.length).fill(false); // Track public tokens
  
  // Initialize public indices from sample if available
  if (sample) {
    // Public assistant indices
    if (sample.public_assistant_indices && Array.isArray(sample.public_assistant_indices)) {
      for (const idx of sample.public_assistant_indices) {
        if (idx >= 0 && idx < tokens.length) {
          isPublic[idx] = true;
        }
      }
    }
    
    // Public user indices - check both possible spellings (indeces and indices)
    if (sample.public_user_indices && Array.isArray(sample.public_user_indices)) {
      for (const idx of sample.public_user_indices) {
        if (idx >= 0 && idx < tokens.length) {
          isPublic[idx] = true;
        }
      }
    }
    
    // Also check the misspelled version (indeces)
    if (sample.public_user_indeces && Array.isArray(sample.public_user_indeces)) {
      for (const idx of sample.public_user_indeces) {
        if (idx >= 0 && idx < tokens.length) {
          isPublic[idx] = true;
        }
      }
    }
  }
  
  // Track conversation state
  let currentState = 'none';  // none, in_header, in_system, in_user, in_assistant
  let headerStartIndex = -1;
  let currentRole = null;
  let systemStartIdx = -1;
  
  // Process tokens sequentially
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token === '<|start_header_id|>') {
      // Start of a header
      currentState = 'in_header';
      headerStartIndex = i;
      isHeader[i] = true;
    }
    else if (currentState === 'in_header' && i === headerStartIndex + 1) {
      // Role token right after start_header_id
      isHeader[i] = true;
      // Store the role we're seeing
      if (token === 'system') {
        currentRole = 'system';
        systemStartIdx = i;
      }
      else if (token === 'user') {
        currentRole = 'user';
      }
      else if (token === 'assistant') {
        currentRole = 'assistant';
      }
      tokenRoles[i] = token; // Store the role token
    }
    else if (token === '<|end_header_id|>') {
      // End of a header
      isHeader[i] = true;
      // Determine which content type we're entering
      if (currentRole) {
        currentState = 'in_' + currentRole;
      }
    }
    else if (token === '<|eot_id|>') {
      // End of text - reset state
      isHeader[i] = true;
      currentState = 'none';
      currentRole = null;
    }
    else if (token === '<|begin_of_text|>') {
      // Special token
      isHeader[i] = true;
    }
    else {
      // Not a header token
      // Set role based on current state
      if (currentState === 'in_system') {
        tokenRoles[i] = 'system';
        isContent[i] = true;
        
        // Mark the date tokens at the beginning of system messages
        // This handles the first ~26 tokens containing date information
        if (systemStartIdx !== -1 && i < systemStartIdx + 30) {
          // Look for the pattern of date tokens
          if (token.includes("Knowledge") || token.includes("Date") || 
              token.includes("December") || token.includes("Today") || 
              token.includes("Jul") || token === "Cut" || token === "ting" ||
              token === ":" || token.match(/^\d+$/) || token === "\u010a\u010a" ||
              token === "\u010a") {
            isDateToken[i] = true;
          }
        }
      }
      else if (currentState === 'in_user') {
        tokenRoles[i] = 'user';
        isContent[i] = true;
      }
      else if (currentState === 'in_assistant') {
        tokenRoles[i] = 'assistant';
        isContent[i] = true;
      }
      else if (currentState === 'in_header') {
        isHeader[i] = true;
      }
    }
  }
  
  return { tokenRoles, isHeader, isContent, isDateToken, isPublic };
}

function displaySample(index) {
  if (!samples || samples.length === 0) return;
  
  const sample = samples[index];
  currentSampleIndex = index;
  currentSampleSpan.textContent = index + 1;
  sampleJump.value = '';
  
  // Update sample ID and label
  sampleIdSpan.textContent = index + 1;
  
  // Store the sample label (but don't display it)
  sampleLabelSpan.textContent = sample.label || '-';
  
  // Hide or show classification buttons based on whether sample is already classified
  if (classifiedSamples.has(index)) {
    classificationButtons.classList.add('classified');
  } else {
    classificationButtons.classList.remove('classified');
  }
  
  // Remove any existing feedback text
  const existingFeedback = document.querySelector('.feedback-text');
  if (existingFeedback) {
    existingFeedback.remove();
  }
  
  // Get tokens and probe scores
  const tokens = sample.tokens || [];
  const probeScores = sample.probe_scores ? sample.probe_scores[currentProbe] || [] : [];
  
  // Store critical indices
  criticalIndices = [];
  if (sample.critical_analysis && Array.isArray(sample.critical_analysis.critical_indices)) {
    criticalIndices = sample.critical_analysis.critical_indices;
  }
  
  // Analyze the conversation including public token information
  const { tokenRoles, isHeader, isContent, isDateToken, isPublic } = analyzeConversation(tokens, sample);
  
  // Update Critical Claim section
  updateCriticalClaimSection(sample, tokens, probeScores, tokenRoles, isHeader, isContent, isDateToken, isPublic);
  
  // Calculate average score for public assistant tokens only
  if (probeScores.length > 0) {
    const publicAssistantScores = [];
    
    for (let i = 0; i < tokens.length; i++) {
      if (isPublic[i] && tokenRoles[i] === 'assistant' && isContent[i]) {
        publicAssistantScores.push(probeScores[i]);
      }
    }
    
    const avgScore = publicAssistantScores.length > 0 ?
      publicAssistantScores.reduce((sum, score) => sum + score, 0) / publicAssistantScores.length : 0;
    
    avgScoreSpan.textContent = avgScore.toFixed(2);
    avgScoreSpan.className = avgScore > 0 ? 'deceptive-score' : 'honest-score';
    
    // Update dashboard statistics
    updateDashboardStats(tokens, probeScores, tokenRoles, isHeader, isContent, isDateToken, isPublic);
    
    // Create HTML with colored tokens
    tokensDisplay.innerHTML = renderTokens(tokens, probeScores, tokenRoles, isHeader, isContent, isDateToken, isPublic);
    
    // Debug information
    const systemCount = tokenRoles.filter(role => role === 'system').length;
    const userCount = tokenRoles.filter(role => role === 'user').length;
    const assistantCount = tokenRoles.filter(role => role === 'assistant').length;
    const headerCount = isHeader.filter(Boolean).length;
    const dateTokenCount = isDateToken.filter(Boolean).length;
    const assistantContentCount = isContent.filter((content, idx) => content && tokenRoles[idx] === 'assistant').length;
    const criticalCount = criticalIndices.length;
    const publicTokenCount = isPublic.filter(Boolean).length;
    
    debugInfo.textContent = `Found ${assistantContentCount} assistant content tokens (headers: ${headerCount}, system: ${systemCount}, user: ${userCount}, assistant: ${assistantCount}, critical: ${criticalCount}, date tokens: ${dateTokenCount}, public tokens: ${publicTokenCount})`;
    
    // If this sample was classified already, display the feedback
    if (classifiedSamples.has(index)) {
      showClassificationFeedback(sample);
    }
    
    // Update follow-ups section
    updateFollowUps(sample);
  } else {
    tokensDisplay.innerHTML = 'No tokens or scores available for this sample.';
  }
}

function updateDashboardStats(tokens, probeScores, tokenRoles, isHeader, isContent, isDateToken, isPublic) {
  // Filter scores to only include public assistant tokens
  const publicAssistantScores = [];
  const allPublicAssistantIndices = [];
  
  for (let i = 0; i < tokens.length; i++) {
    // Only include assistant tokens that are public
    if (isPublic[i] && tokenRoles[i] === 'assistant' && isContent[i]) {
      publicAssistantScores.push(probeScores[i]);
      allPublicAssistantIndices.push(i);
    }
  }
  
  // Calculate mean score over critical tokens
  let criticalTokensScore = 0;
  let criticalTokensCount = 0;
  
  for (const idx of criticalIndices) {
    if (isPublic[idx] && tokenRoles[idx] === 'assistant' && idx < probeScores.length) {
      criticalTokensScore += probeScores[idx];
      criticalTokensCount++;
    }
  }
  
  const avgCriticalScore = criticalTokensCount > 0 ? 
    criticalTokensScore / criticalTokensCount : 0;
  
  // Use the public assistant scores for statistics
  const avg = publicAssistantScores.length > 0 ?
    publicAssistantScores.reduce((sum, score) => sum + score, 0) / publicAssistantScores.length : 0;
  
  // Sort scores for median and percentiles
  const sortedScores = [...publicAssistantScores].sort((a, b) => a - b);
  const median = sortedScores.length > 0 ? 
    sortedScores[Math.floor(sortedScores.length / 2)] : 0;
  const max = sortedScores.length > 0 ? 
    Math.max(...publicAssistantScores) : 0;
  
  // Count tokens above zero
  const tokensAboveZero = publicAssistantScores.filter(score => score > 0).length;
  
  // Calculate percentage
  const pctAboveZero = publicAssistantScores.length > 0 ? 
    ((tokensAboveZero / publicAssistantScores.length) * 100) : 0;
  
  // Format the percentage with one decimal place
  const formattedPctAboveZero = pctAboveZero.toFixed(1);
  
  // Update the dashboard
  avgDeceptionScore.textContent = avg.toFixed(2);
  avgDeceptionScore.className = avg > 0 ? 'deceptive-score' : 'honest-score';
  
  medianScore.textContent = median.toFixed(2);
  medianScore.className = median > 0 ? 'deceptive-score' : 'honest-score';
  
  peakScore.textContent = max.toFixed(2);
  peakScore.className = max > 0 ? 'deceptive-score' : 'honest-score';
  
  // Update tokens above zero with color based on percentage
  tokensAboveZeroElement.textContent = `${tokensAboveZero} (${formattedPctAboveZero}%)`;
  tokensAboveZeroElement.className = pctAboveZero > 50 ? 'deceptive-score' : 'honest-score';
  
  // Update response tokens count
  totalTokens.textContent = publicAssistantScores.length.toString();
  
  // Update critical tokens average score
  const criticalScoreElement = document.getElementById('critical-tokens-avg');
  if (criticalScoreElement) {
    criticalScoreElement.textContent = avgCriticalScore.toFixed(2);
    criticalScoreElement.className = avgCriticalScore > 0 ? 'deceptive-score' : 'honest-score';
  }
  
  // Generate suspicious regions (assistant only)
  updateSuspiciousRegions(tokens, probeScores, tokenRoles, isHeader, isContent, isDateToken, isPublic);
}

function updateSuspiciousRegions(tokens, probeScores, tokenRoles, isHeader, isContent, isDateToken, isPublic) {
  suspiciousRegionsDiv.innerHTML = '';
  
  // Find top suspicious regions with context
  const contextWindow = 5;  // tokens before/after suspicious token
  const regionLimit = 5;    // max regions to identify
  
  // Create array of indices sorted by score (descending), but only for public assistant content tokens
  const assistantContentIndices = [];
  for (let i = 0; i < tokens.length; i++) {
    // Only include public assistant tokens
    if (isPublic[i] && isContent[i] && tokenRoles[i] === 'assistant') {
      assistantContentIndices.push(i);
    }
  }
  
  // Sort by score (highest first)
  assistantContentIndices.sort((a, b) => probeScores[b] - probeScores[a]);
  
  // Keep track of which tokens we've already covered in a region
  const covered = new Set();
  const suspiciousRegions = [];
  
  // Find the top suspicious regions
  for (const idx of assistantContentIndices) {
    // Skip if this token is already in a region
    if (covered.has(idx) || suspiciousRegions.length >= regionLimit) continue;
    
    // Skip if score isn't very high
    if (probeScores[idx] < 1.0) break;
    
    // Define region boundaries, but stay within visible assistant tokens
    let start = idx, end = idx;
    let tokensToAdd = contextWindow;
    
    // Expand backward within public assistant tokens
    for (let i = idx - 1; i >= 0 && tokensToAdd > 0; i--) {
      if (isPublic[i] && isContent[i] && tokenRoles[i] === 'assistant') {
        start = i;
        tokensToAdd--;
      }
    }
    
    // Reset tokens to add
    tokensToAdd = contextWindow;
    
    // Expand forward within public assistant tokens
    for (let i = idx + 1; i < tokens.length && tokensToAdd > 0; i++) {
      if (isPublic[i] && isContent[i] && tokenRoles[i] === 'assistant') {
        end = i;
        tokensToAdd--;
      }
    }
    
    // Mark all tokens in this region as covered
    for (let i = start; i <= end; i++) {
      covered.add(i);
    }
    
    // Extract the region text and peak score
    const regionTokens = [];
    for (let i = start; i <= end; i++) {
      // Only include public tokens
      if (isPublic[i] && isContent[i] && tokenRoles[i] === 'assistant') {
        regionTokens.push(tokens[i]);
      }
    }
    
    const peakScore = probeScores[idx];
    
    // Create a text representation of the region
    const regionText = regionTokens.map(displayCleaned).join(' ');
    
    // Add to regions list
    suspiciousRegions.push({
      text: regionText,
      peakScore: peakScore,
      index: idx
    });
  }
  
  // Render the suspicious regions
  if (suspiciousRegions.length > 0) {
    // Sort regions by peak score (highest first)
    suspiciousRegions.sort((a, b) => b.peakScore - a.peakScore);
    
    suspiciousRegions.forEach((region, i) => {
      // Calculate color based on peak score
      const colorStyle = getTokenColor(region.peakScore);
      
      suspiciousRegionsDiv.innerHTML += `
        <div class="suspicious-region" style="background-color: ${colorStyle.bgColor}; color: ${colorStyle.textColor};">
          ${region.text}
          <span class="suspicious-region-score" style="background-color: var(--pivotal-orange);">${region.peakScore.toFixed(2)}</span>
        </div>
      `;
    });
  } else {
    suspiciousRegionsDiv.innerHTML = '<p>No significant deceptive regions found in assistant responses.</p>';
  }
}

// Helper function to extract just the last assistant response from tokens
function extractLastAssistantResponse(tokens, tokenRoles, isContent) {
  let assistantContent = [];
  let lastAssistantStart = -1;
  let lastAssistantEnd = -1;
  let inAssistant = false;
  
  // Find the last assistant message
  for (let i = 0; i < tokens.length; i++) {
    if (tokenRoles[i] === 'assistant' && isContent[i]) {
      if (!inAssistant) {
        inAssistant = true;
        lastAssistantStart = i;
      }
      lastAssistantEnd = i;
    } else if (tokens[i] === '<|eot_id|>' && inAssistant) {
      inAssistant = false;
    }
  }
  
  // Extract the assistant message content
  if (lastAssistantStart >= 0 && lastAssistantEnd >= lastAssistantStart) {
    for (let i = lastAssistantStart; i <= lastAssistantEnd; i++) {
      if (tokenRoles[i] === 'assistant' && isContent[i]) {
        assistantContent.push(displayCleaned(tokens[i]));
      }
    }
  }
  
  return assistantContent.length > 0 ? assistantContent.join(' ') : "No response available";
}

function updateFollowUps(sample) {
  const followUpsContainer = document.getElementById('follow-ups-container');
  
  // Create hard-coded follow-up data for only the two selected follow-ups
  const hardcodedFollowUps = [
    {
      name: "was_your_response_deceptive_no",
      display_name: "When asked if deceptive → No",
      question: "Was your response deceptive?",
      assistant_response: "No",
      response_score: -1.60
    },
    {
      name: "was_your_response_honest_yes",
      display_name: "When asked if honest → Yes",
      question: "Was your response honest?",
      assistant_response: "Yes",
      response_score: -1.37
    }
  ];
  
  // Use actual follow-up scores if available in the sample
  if (sample.follow_ups) {
    for (const [followUpType, followUpData] of Object.entries(sample.follow_ups)) {
      const matchingFollowUp = hardcodedFollowUps.find(f => f.name === followUpType);
      if (matchingFollowUp) {
        // Get probe scores for the current probe
        const followUpProbeScores = followUpData.probe_scores?.[currentProbe] || [];
        
        // Calculate score for the last assistant response
        let finalResponseScore = 0;
        
        if (followUpData.tokens && followUpData.tokens.length > 0) {
          const { tokenRoles, isContent } = analyzeConversation(followUpData.tokens || [], followUpData);
          let lastAssistantStart = -1;
          let lastAssistantEnd = -1;
          let inAssistant = false;
          
          for (let i = 0; i < followUpData.tokens.length; i++) {
            if (tokenRoles[i] === 'assistant' && isContent[i]) {
              if (!inAssistant) {
                inAssistant = true;
                lastAssistantStart = i;
              }
              lastAssistantEnd = i;
            } else if (followUpData.tokens[i] === '<|eot_id|>' && inAssistant) {
              inAssistant = false;
            }
          }
          
          if (lastAssistantStart >= 0 && lastAssistantEnd >= lastAssistantStart) {
            const finalResponseScores = followUpProbeScores.slice(lastAssistantStart, lastAssistantEnd + 1);
            finalResponseScore = finalResponseScores.reduce((sum, score) => sum + score, 0) / finalResponseScores.length || 0;
            matchingFollowUp.response_score = finalResponseScore;
          }
        }
      }
    }
  }
  
  let html = '';
  
  // Create content for each follow-up
  hardcodedFollowUps.forEach((followUp, index) => {
    const followUpId = `followup-${index}`;
    const headerId = `header-${followUpId}`;
    const contentId = `content-${followUpId}`;
    
    // Style based on score
    let scoreClass = '';
    if (followUp.response_score >= 0.8) {
      scoreClass = 'high-score';
    } else if (followUp.response_score >= 0.5) {
      scoreClass = 'medium-score';
    } else {
      scoreClass = 'low-score';
    }
    
    // Display score with appropriate coloring
    const scoreColorClass = followUp.response_score > 0 ? 'deceptive-score' : 'honest-score';
    
    html += `
      <div class="follow-up-item ${scoreClass}">
        <div class="follow-up-header" id="${headerId}">
          <div class="follow-up-title">${followUp.display_name}</div>
          <div class="follow-up-score">
            Score: <span class="${scoreColorClass}">${followUp.response_score.toFixed(2)}</span>
          </div>
          <div class="follow-up-toggle">▼</div>
        </div>
        <div class="follow-up-content" id="${contentId}">
          <div class="follow-up-conversation">
            <div class="follow-up-message user-message">
              <div class="message-emoji">👤</div>
              <div class="message-content">${escapeHtml(followUp.question)}</div>
            </div>
            <div class="follow-up-message assistant-message">
              <div class="message-emoji">🤖</div>
              <div class="message-content">${escapeHtml(followUp.assistant_response)}</div>
            </div>
          </div>
        </div>
      </div>
    `;
  });
  
  followUpsContainer.innerHTML = html;
  
  // Add event listeners to toggle content visibility
  document.querySelectorAll('.follow-up-header').forEach((header) => {
    header.addEventListener('click', () => {
      const content = header.nextElementSibling;
      const toggle = header.querySelector('.follow-up-toggle');
      
      if (content.style.maxHeight) {
        content.style.maxHeight = null;
        toggle.textContent = '▼';
      } else {
        content.style.maxHeight = content.scrollHeight + 'px';
        toggle.textContent = '▲';
      }
    });
  });
}

function renderTokens(tokens, probeScores, tokenRoles, isHeader, isContent, isDateToken, isPublic) {
  let html = '<div class="colored-tokens">';
  let assistantContentCount = 0;
  let isInHeader = false; // Track if we're in a header section
  
  // Group tokens together
  let headerTokens = [];
  let contentTokens = [];
  let currentRole = null;
  let messageStarted = false;
  let dateTokensEndIndex = -1;
  let lastRoleSeen = null;
  let addedBreakAfterRole = false;
  
  // Find the last date token to add a line break after it
  for (let i = tokens.length-1; i >= 0; i--) {
    if (isDateToken[i]) {
      dateTokensEndIndex = i;
      break;
    }
  }
  
  // Create map of roles to track if they have public content
  const roleHasPublicContent = {
    'system': false,
    'user': false,
    'assistant': false
  };
  
  // Check which roles have public content
  for (let i = 0; i < tokens.length; i++) {
    const role = tokenRoles[i];
    if (isPublic[i] && (role === 'system' || role === 'user' || role === 'assistant')) {
      roleHasPublicContent[role] = true;
    }
  }
  
  // Track current message role and its visible content status
  let currentMessageRole = null;
  let currentMessageHasContent = false;
  
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    const role = tokenRoles[i];
    
    // By default, only show public user and assistant tokens
    // Hide all header, system, date tokens, and non-public tokens
    const isSpecialToken = isHeader[i] || role === 'system' || isDateToken[i];
    const shouldHide = !isPublic[i] || isSpecialToken;
    
    // Start of a new message
    if (token === '<|start_header_id|>' && i+1 < tokens.length && tokenRoles[i+1] !== currentMessageRole) {
      // End previous message if there was one
      if (messageStarted) {
        // If the current message had no visible content, add placeholder
        if (!currentMessageHasContent && !showHiddenTokens) {
          html += `<div style="color: #888; font-style: italic; margin: 5px 0;">${currentMessageRole || 'Unknown'} message hidden - toggle to reveal</div>`;
        }
        html += '</div>'; // Close message-container
        messageStarted = false;
      }
      
      // Store the role of the upcoming message
      if (i+1 < tokens.length) {
        currentMessageRole = tokenRoles[i+1];
        currentMessageHasContent = false;
      }
    }
    
    // Check if we're starting a new section
    if (token === '<|start_header_id|>') {
      // If we have content tokens, render them first
      if (contentTokens.length > 0) {
        html += renderContentTokens(contentTokens, probeScores, isDateToken, dateTokensEndIndex, isPublic);
        contentTokens = [];
      }
      // Start collecting header tokens
      isInHeader = true;
      headerTokens.push({ index: i, token });
    }
    // Check if we're ending a header section
    else if (token === '<|end_header_id|>') {
      // Add this token to header tokens
      headerTokens.push({ index: i, token });
      // Render header tokens if showing all tokens
      if (showHiddenTokens) {
        html += renderHeaderTokens(headerTokens, probeScores);
      }
      headerTokens = [];
      
      // Add a line break if showing all tokens
      if (showHiddenTokens) {
        html += '<div class="role-break"></div>';
      }
      isInHeader = false;
      
      // Start a new message container with appropriate emoji - always show emojis
      if (currentRole) {
        let emoji = '';
        if (currentRole === 'system') emoji = '💻';
        else if (currentRole === 'user') emoji = '👤';
        else if (currentRole === 'assistant') emoji = '🤖';
        
        // Always show message container and emoji
        html += `<div class="message-container">`;
        html += `<div class="message-emoji">${emoji}</div>`;
        messageStarted = true;
        currentMessageHasContent = false; // Reset for new message
      }
    }
    // Check if we're at end of a message
    else if (token === '<|eot_id|>') {
      // If we have content tokens, render them first
      if (contentTokens.length > 0) {
        html += renderContentTokens(contentTokens, probeScores, isDateToken, dateTokensEndIndex, isPublic);
        contentTokens = [];
      }
      
      // Render this token as header if showing all tokens
      if (showHiddenTokens) {
        html += renderHeaderTokens([{ index: i, token }], probeScores);
      }
      
      // Add a line break if showing all tokens
      if (showHiddenTokens) {
        html += '<div class="role-break"></div>';
      } else {
        // If not showing all tokens, add a smaller break
        html += '<div style="height: 5px;"></div>';
      }
      
      // Close message container if one was open
      if (messageStarted) {
        // If the message had no visible content, add placeholder
        if (!currentMessageHasContent && !showHiddenTokens) {
          const roleName = currentRole ? currentRole.charAt(0).toUpperCase() + currentRole.slice(1) : 'Unknown';
          html += `<div style="color: #888; font-style: italic; margin: 5px 0;">${roleName} message hidden - toggle to reveal</div>`;
        }
        html += '</div>'; // Close message-container
        messageStarted = false;
      }
    }
    // For other tokens
    else {
      if (isInHeader || isHeader[i]) {
        headerTokens.push({ index: i, token });
        
        // If this is the role token right after start_header_id, store it
        if (isInHeader && headerTokens.length === 2) {
          currentRole = token; // Store the role (system, user, assistant)
        }
      } else {
        // Count assistant tokens
        if (role === 'assistant') {
          assistantContentCount++;
        }
        
        // Mark that this message has visible content if the token will be shown
        if (!shouldHide || showHiddenTokens) {
          currentMessageHasContent = true;
        }
        
        contentTokens.push({ index: i, token, role });
      }
    }
  }
  
  // Render any remaining tokens
  if (headerTokens.length > 0 && showHiddenTokens) {
    html += renderHeaderTokens(headerTokens, probeScores);
  }
  if (contentTokens.length > 0) {
    html += renderContentTokens(contentTokens, probeScores, isDateToken, dateTokensEndIndex, isPublic);
  }
  
  // Close message container if still open
  if (messageStarted) {
    // If the message had no visible content, add placeholder
    if (!currentMessageHasContent && !showHiddenTokens) {
      const roleName = currentRole ? currentRole.charAt(0).toUpperCase() + currentRole.slice(1) : 'Unknown';
      html += `<div style="color: #888; font-style: italic; margin: 5px 0;">${roleName} message hidden - toggle to reveal</div>`;
    }
    html += '</div>'; // Close message-container
  }
  
  // If showHiddenTokens is off, inform user that tokens are hidden
  if (!showHiddenTokens) {
    html = '<div style="color: #888; margin-bottom: 10px;"><i>Only showing public tokens. Toggle "Reveal hidden tokens" to see all content including system prompts and special tokens.</i></div>' + html;
  }
  
  html += '</div>';
  return html;
}

function renderHeaderTokens(tokens, probeScores) {
  let html = '';
  for (const item of tokens) {
    const { index, token } = item;
    const score = probeScores[index];
    
    // Get token colors
    let colors;
    if (assistantOnly) {
      // When assistantOnly is on, all header tokens have white backgrounds
      colors = { bgColor: 'rgb(255, 255, 255)', textColor: '#888' };
    } else {
      // Otherwise, use colored backgrounds
      colors = getTokenColor(score);
      // But always use gray text for headers
      colors.textColor = '#888';
    }
    
    // Special handling for exactly Ċ character tokens or \u010a - pure line breaks
    if (token === 'Ċ' || token === '\u010a') {
      html += '<div class="token-break"></div>'; // Line break for code blocks
      continue;
    }
    
    // Process the token for display
    let displayToken = token;
    
    // Handle tokens with space markers and other special characters
    if (token.startsWith('\u0120') || token.startsWith('Ġ')) {
      // Token starts with a space
      displayToken = ' ' + token.substring(1);
      displayToken = displayToken.replace(/Ġ/g, ' ');
    } else {
      // Replace all Ġ with spaces
      displayToken = displayToken.replace(/Ġ/g, ' ');
    }
    
    // For all Ċ or \u010a characters inside a token, replace with <br> tags directly
    if (displayToken.includes('Ċ') || displayToken.includes('\u010a')) {
      // Split by Ċ and join with <br>
      let parts = displayToken.split('Ċ');
      displayToken = parts.join('<br class="token-line-break">');
      
      // Also handle \u010a explicitly
      parts = displayToken.split('\u010a');
      displayToken = parts.join('<br class="token-line-break">');
    }
    
    // Escape HTML for safety, except for our inserted <br> tags
    if (displayToken.includes('<br')) {
      // Only escape the parts that aren't <br>
      const safeDisplay = displayToken
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/&lt;br class="token-line-break"&gt;/g, '<br class="token-line-break">')
        .replace(/&lt;br&gt;/g, '<br>');
      
      html += `<span><span
        class="token header-token"
        style="display: inline-block; background-color: ${colors.bgColor}; color: ${colors.textColor};
        line-height: 1.2em; padding: 3px 0px; margin-left: -1px; margin-bottom: 1px;
        border-width: 1px; border-style: solid; border-color: rgb(238, 238, 238);"
        data-score="${score !== undefined ? score.toFixed(2) : 'N/A'}"
      >${safeDisplay}</span></span>`;
    } else {
      // No special HTML characters
      html += `<span><span
        class="token header-token"
        style="display: inline-block; background-color: ${colors.bgColor}; color: ${colors.textColor};
        line-height: 1.2em; padding: 3px 0px; margin-left: -1px; margin-bottom: 1px;
        border-width: 1px; border-style: solid; border-color: rgb(238, 238, 238);"
        data-score="${score !== undefined ? score.toFixed(2) : 'N/A'}"
      >${escapeHtml(displayToken)}</span></span>`;
    }
  }
  return html;
}

function renderContentTokens(tokens, probeScores, isDateToken, dateTokensEndIndex, isPublic) {
  let html = '';
  // Detect which role these content tokens belong to
  const role = tokens.length > 0 ? tokens[0].role : 'unknown';
  
  // Track state for maintaining line breaks when tokens are hidden
  let lastTokenWasHidden = false;
  let lineBreakAdded = false;
  
  // Check if this might be a code block (heuristic: has multiple \u010a characters)
  let codeBlockCheck = tokens.map(item => item.token).join('');
  const hasMultipleNewlines = (codeBlockCheck.match(/\u010a/g) || []).length > 2;
  const hasCodeKeywords = codeBlockCheck.includes('include') || 
                          codeBlockCheck.includes('function') || 
                          codeBlockCheck.includes('class') || 
                          codeBlockCheck.includes('namespace') ||
                          codeBlockCheck.includes('int') && codeBlockCheck.includes('main');
  const isLikelyCodeBlock = hasMultipleNewlines && hasCodeKeywords;
  
  // Check if any tokens will be visible
  const hasVisibleTokens = tokens.some(item => {
    const isSpecialToken = item.role === 'system' || isDateToken[item.index];
    const shouldHide = !isPublic[item.index] || isSpecialToken;
    return !shouldHide || showHiddenTokens;
  });
  
  // If no visible tokens, we'll let the parent function handle the message placeholder
  if (!hasVisibleTokens && !showHiddenTokens) {
    return '';
  }
  
  if (isLikelyCodeBlock) {
    // Special rendering for code blocks
    html += '<div class="code-block">';
    let currentLine = '';
    let codeLineBreakNeeded = false;
    
    for (const item of tokens) {
      const { index, token, role } = item;
      
      // Skip hidden tokens - only show public tokens unless toggle is on
      const isSpecialToken = role === 'system' || isDateToken[index];
      const shouldHide = !isPublic[index] || isSpecialToken;
      
      // When a token is hidden but we're in a code block, check if we need to add a line break
      if (shouldHide && !showHiddenTokens) {
        if (token === 'Ċ' || token === '\u010a') {
          codeLineBreakNeeded = true;
        }
        continue;
      }
      
      // Add a line break if needed from skipped content
      if (codeLineBreakNeeded) {
        if (currentLine) {
          html += `<div class="code-line">${currentLine}</div>`;
          currentLine = '';
        } else {
          html += '<div class="code-line">&nbsp;</div>'; // Empty line
        }
        codeLineBreakNeeded = false;
      }
      
      const score = probeScores[index];
      const isAssistant = item.role === 'assistant';
      const isCritical = showCritical && criticalIndices.includes(index);
      
      // Determine color based on token score
      let colors;
      if (assistantOnly) {
        if (isAssistant) {
          colors = getTokenColor(score);
        } else {
          colors = { bgColor: 'transparent', textColor: 'black' };
        }
      } else {
        colors = getTokenColor(score);
      }
      
      // Process token for display
      let displayToken = token;
      
      // Handle standalone newlines
      if (token === 'Ċ' || token === '\u010a') {
        if (currentLine) {
          html += `<div class="code-line">${currentLine}</div>`;
          currentLine = '';
        } else {
          html += '<div class="code-line">&nbsp;</div>'; // Empty line
        }
        continue;
      }
      
      // Check for calibration tags
      if (token.includes('<calibrate') || token.includes('</calibrate>')) {
        if (currentLine) {
          html += `<div class="code-line">${currentLine}</div>`;
          currentLine = '';
        }
        // Add the calibrate tag on its own line
        currentLine += `<span class="token ${isCritical ? 'token-critical' : ''}" 
          style="color: ${colors.textColor}; background-color: ${colors.bgColor};"
          data-score="${score !== undefined ? score.toFixed(2) : 'N/A'}"
          data-role="${item.role}">${escapeHtml(token)}</span>`;
        html += `<div class="code-line">${currentLine}</div>`;
        currentLine = '';
        continue;
      }
      
      // Process spaces and special characters
      if (token.startsWith('\u0120') || token.startsWith('Ġ')) {
        displayToken = ' ' + token.substring(1);
        displayToken = displayToken.replace(/Ġ/g, ' ');
      } else {
        // Handle indentation
        const indentMatch = token.match(/^(Ġ+)/);
        if (indentMatch) {
          const indentCount = indentMatch[0].length;
          const indent = '&nbsp;'.repeat(indentCount * 2);
          displayToken = indent + token.substring(indentCount);
        } else {
          displayToken = displayToken.replace(/Ġ/g, ' ');
        }
      }
      
      // Handle embedded newlines
      if (displayToken.includes('\u010a') || displayToken.includes('Ċ')) {
        const lines = displayToken.replace(/Ċ/g, '\u010a').split('\u010a');
        for (let i = 0; i < lines.length; i++) {
          if (i > 0 && currentLine) {
            html += `<div class="code-line">${currentLine}</div>`;
            currentLine = '';
          }
          const line = lines[i];
          if (i === lines.length - 1) {
            // Last part goes into current line
            currentLine += `<span class="token ${isCritical ? 'token-critical' : ''}" 
              style="color: ${colors.textColor}; background-color: ${colors.bgColor};"
              data-score="${score !== undefined ? score.toFixed(2) : 'N/A'}"
              data-role="${item.role}">${escapeHtml(line)}</span>`;
          } else {
            // Complete line with a line break
            currentLine += `<span class="token ${isCritical ? 'token-critical' : ''}" 
              style="color: ${colors.textColor}; background-color: ${colors.bgColor};"
              data-score="${score !== undefined ? score.toFixed(2) : 'N/A'}"
              data-role="${item.role}">${escapeHtml(line)}</span>`;
            html += `<div class="code-line">${currentLine}</div>`;
            currentLine = '';
          }
        }
      } else {
        // Regular token without newlines
        currentLine += `<span class="token ${isCritical ? 'token-critical' : ''}" 
          style="color: ${colors.textColor}; background-color: ${colors.bgColor};"
          data-score="${score !== undefined ? score.toFixed(2) : 'N/A'}"
          data-role="${item.role}">${escapeHtml(displayToken)}</span>`;
      }
    }
    
    // Add any remaining line
    if (currentLine) {
      html += `<div class="code-line">${currentLine}</div>`;
    }
    
    html += '</div>'; // Close code block
  } else {
    // Regular content token rendering
    let previousTokenIndex = -1;
    let visibleTokenCount = 0;
    
    for (const item of tokens) {
      const { index, token, role } = item;
      
      // Skip hidden tokens - only show public tokens unless toggle is on
      const isSpecialToken = role === 'system' || isDateToken[index];
      const shouldHide = !isPublic[index] || isSpecialToken;
      
      // When tokens are hidden, maintain paragraph structure
      if (shouldHide && !showHiddenTokens) {
        // If we've skipped many tokens, add a paragraph break 
        // This helps maintain readable text flow even when tokens are hidden
        if (previousTokenIndex >= 0 && index - previousTokenIndex > 10 && !lineBreakAdded) {
          html += '<div class="token-break"></div>';
          lineBreakAdded = true;
        }
        
        // If we encounter newlines in hidden tokens, preserve them for readability
        if (token === 'Ċ' || token === '\u010a') {
          html += '<div class="token-break"></div>';
          lineBreakAdded = true;
        }
        
        lastTokenWasHidden = true;
        continue;
      }
      
      // Count visible tokens
      visibleTokenCount++;
      
      // Reset line break tracker when we show a token
      lineBreakAdded = false;
      lastTokenWasHidden = false;
      previousTokenIndex = index;
      
      const score = probeScores[index];
      const isAssistant = item.role === 'assistant';
      const isCritical = showCritical && criticalIndices.includes(index);
      const isDate = isDateToken && isDateToken[index];
      const isLastDateToken = index === dateTokensEndIndex;
      
      // Get token colors
      let colors;
      if (assistantOnly) {
        // When assistantOnly is on, only assistant content tokens get colored
        if (isAssistant) {
          colors = getTokenColor(score);
        } else {
          colors = { bgColor: 'rgb(255, 255, 255)', textColor: 'black' };
        }
      } else {
        // When assistantOnly is off, all content tokens get colored
        colors = getTokenColor(score);
      }
      
      // If this is a date token, override the colors
      if (isDate) {
        colors = { bgColor: 'rgb(255, 255, 255)', textColor: '#888' };
      }
      
      // Special handling for exactly Ċ character tokens or \u010a - pure line breaks
      if (token === 'Ċ' || token === '\u010a') {
        html += '<div class="token-break"></div>'; // Line break
        continue;
      }
      
      // Check for calibration tags
      const hasCalibrateTags = token.includes('<calibrate') || token.includes('</calibrate>');
      
      // Process the token for display
      let displayToken = token;
      
      // Handle tokens with space markers and other special characters
      if (token.startsWith('\u0120') || token.startsWith('Ġ')) {
        // Token starts with a space
        displayToken = ' ' + token.substring(1);
        displayToken = displayToken.replace(/Ġ/g, ' ');
      } else {
        // Handle multiple consecutive Ġ characters for indentation
        const indentMatch = token.match(/^(Ġ+)/);
        if (indentMatch) {
          const indentCount = indentMatch[0].length;
          const indent = '&nbsp;'.repeat(indentCount * 2);
          displayToken = indent + token.substring(indentCount);
        } else {
          // Replace all remaining Ġ with spaces
          displayToken = displayToken.replace(/Ġ/g, ' ');
        }
      }
      
      // For all Ċ or \u010a characters inside a token, replace with <br> tags directly
      if (displayToken.includes('Ċ') || displayToken.includes('\u010a')) {
        // Split by Ċ and join with <br>
        let parts = displayToken.split('Ċ');
        displayToken = parts.join('<br>');
        
        // Also handle \u010a explicitly
        parts = displayToken.split('\u010a');
        displayToken = parts.join('<br>');
      }
      
      // Add line break before/after calibration tags
      if (hasCalibrateTags) {
        displayToken = displayToken
          .replace(/<calibrate[^>]*>/g, '<br><span style="color:#888;">&lt;calibrate&gt;</span><br>')
          .replace(/<\/calibrate>/g, '<br><span style="color:#888;">&lt;/calibrate&gt;</span><br>');
      }
      
      // Add line break after the last date token
      if (isLastDateToken) {
        displayToken += '<br><br><br>'; // Add extra line breaks for spacing
      }
      
      // Determine token class
      const tokenClass = isCritical ? 'token token-critical' : 'token';
      
      // For date tokens, apply the header-token style
      const tokenStyle = isDate ? 'token header-token' : tokenClass;
      
      // Escape HTML for safety, except for our inserted <br> and &nbsp; tags
      if (displayToken.includes('<br') || displayToken.includes('&nbsp;') || displayToken.includes('<span')) {
        // Only escape the parts that aren't <br> or &nbsp; or <span>
        const safeDisplay = displayToken
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/&lt;br&gt;/g, '<br>')
          .replace(/&lt;br class="token-line-break"&gt;/g, '<br>')
          .replace(/&amp;nbsp;/g, '&nbsp;')
          .replace(/&lt;span style="color:#888;"&gt;/g, '<span style="color:#888;">')
          .replace(/&lt;\/span&gt;/g, '</span>');
        
        html += `<span><span
          class="${tokenStyle}"
          style="background-color: ${colors.bgColor}; color: ${colors.textColor};
          padding: 3px 0px; margin-bottom: 1px; white-space: pre-wrap;"
          data-score="${score !== undefined ? score.toFixed(2) : 'N/A'}"
          data-role="${item.role}"
        >${safeDisplay}</span></span>`;
      } else {
        // No special HTML characters
        html += `<span><span
          class="${tokenStyle}"
          style="background-color: ${colors.bgColor}; color: ${colors.textColor};
          padding: 3px 0px; margin-bottom: 1px; white-space: pre-wrap;"
          data-score="${score !== undefined ? score.toFixed(2) : 'N/A'}"
          data-role="${item.role}"
        >${escapeHtml(displayToken)}</span></span>`;
      }
    }
  }
  
  return html;
}

function displayCleaned(token) {
  // Check if the token is exactly "Ċ" or "\u010a" (line break)
  if (token === 'Ċ' || token === '\u010a') {
    return ' '; // Replace with space for cleaned display
  }
  
  let cleaned = token
    .replace(/\u010a/g, ' ')
    .replace(/Ċ/g, ' ')  // Use space instead of newline for simplified text display
    .replace(/\u0120/g, ' ')
    .replace(/Ġ/g, ' ')
    .replace(/<\|.*?\|>/g, '')
    .trim();
  
  // Further cleaning for any remaining special characters
  cleaned = cleaned.replace(/[\u0100-\u01FF]/g, ' ');
  
  return cleaned;
}

function escapeHtml(unsafe) {
  return unsafe
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function updateCriticalClaimSection(sample, tokens, probeScores, tokenRoles, isHeader, isContent, isDateToken, isPublic) {
  const criticalClaimSection = document.getElementById('critical-claim-section');
  
  // Check if critical analysis data exists
  if (!sample.critical_analysis) {
    criticalClaimSection.innerHTML = '<p>No critical claim available for this sample.</p>';
    return;
  }
  
  // Extract critical analysis data
  const { user_query, critical_indices } = sample.critical_analysis;
  
  // Ensure we have critical indices
  if (!critical_indices || !Array.isArray(critical_indices) || critical_indices.length === 0) {
    criticalClaimSection.innerHTML = '<p>No critical tokens identified for this sample.</p>';
    return;
  }
  
  // Calculate average score for critical tokens that are visible
  let criticalScores = [];
  let visibleCriticalTokens = [];
  
  if (probeScores && probeScores.length >= Math.max(...critical_indices)) {
    for (const idx of critical_indices) {
      // Check if this token should be visible with current settings
      const isSpecialToken = isHeader[idx] || tokenRoles[idx] === 'system' || isDateToken[idx];
      const shouldHide = !isPublic[idx] || isSpecialToken;
      
      if (!shouldHide || showHiddenTokens) {
        criticalScores.push(probeScores[idx]);
        visibleCriticalTokens.push(tokens[idx]);
      }
    }
  }
  
  // If no visible critical tokens, show message
  if (visibleCriticalTokens.length === 0) {
    criticalClaimSection.innerHTML = '<p>No visible critical tokens with current visibility settings.</p>';
    return;
  }
  
  const avgCriticalScore = criticalScores.length > 0 
    ? criticalScores.reduce((sum, score) => sum + score, 0) / criticalScores.length 
    : 0;
  
  // Construct the critical claim from the visible tokens
  const criticalTokensText = visibleCriticalTokens.map(token => displayCleaned(token)).join(' ').trim();
  
  // Get colors based on average score
  const colorStyle = getTokenColor(avgCriticalScore);
  
  // Create HTML for critical claim section with improved styling
  criticalClaimSection.innerHTML = `
    <div class="suspicious-region" style="background-color: ${colorStyle.bgColor}; color: ${colorStyle.textColor};">
      ${user_query ? `<p style="font-size: 0.85em; color: #888; margin-bottom: 8px;">${escapeHtml(user_query)}</p>` : ''}
      <p>${escapeHtml(criticalTokensText)}</p>
      <span class="suspicious-region-score" style="background-color: ${avgCriticalScore > 0 ? 'var(--pivotal-orange)' : 'var(--pivotal-blue)'};">${avgCriticalScore.toFixed(2)}</span>
    </div>
  `;
}

// Game-related functions
function resetGame() {
  gameScore = 0;
  totalAttempts = 0;
  classifiedSamples.clear();
  gameScoreDisplay.textContent = '0';
  totalAttemptsDisplay.textContent = '0';
  
  // Remove any existing feedback text
  const existingFeedback = document.querySelector('.feedback-text');
  if (existingFeedback) {
    existingFeedback.remove();
  }
  
  // Show classification buttons
  classificationButtons.classList.remove('classified');
  
  // Reset the current sample display
  displaySample(currentSampleIndex);
}

function handleClassification(classification) {
  // Prevent re-classifying the same sample
  if (classifiedSamples.has(currentSampleIndex)) return;
  
  const sample = samples[currentSampleIndex];
  const isCorrect = classification === sample.label;
  
  totalAttempts++;
  if (isCorrect) {
    gameScore++;
    // Trigger confetti for correct answers
    confetti({
      particleCount: 100,
      spread: 70,
      origin: { y: 0.6 }
    });
  }
  
  // Update score displays
  gameScoreDisplay.textContent = gameScore;
  totalAttemptsDisplay.textContent = totalAttempts;
  
  // Mark sample as classified
  classifiedSamples.add(currentSampleIndex);
  classificationButtons.classList.add('classified');
  
  // Show feedback
  showClassificationFeedback(sample, classification);
}

function showClassificationFeedback(sample, classification) {
  if (!classification) {
    // If no classification provided, this is for a previously classified sample
    // Just return as we don't know what the user's guess was
    return;
  }
  
  // Generate feedback text
  let feedbackText = '';
  let feedbackClass = '';
  let feedbackEmoji = '';
  const groundTruth = sample.label === 'honest' ? '(Llama was honest)' : '(Llama was lying)';
  
  if (sample.label === 'honest') {
    if (classification === 'honest') {
      feedbackText = `Correct ${groundTruth}`;
      feedbackClass = 'honest';
      feedbackEmoji = '👮 '; // Police officer emoji for correct
    } else {
      feedbackText = `Incorrect ${groundTruth}`;
      feedbackClass = 'honest';
      feedbackEmoji = '🚨 '; // Alarm emoji for incorrect
    }
  } else {
    if (classification === 'honest') {
      feedbackText = `Incorrect ${groundTruth}`;
      feedbackClass = 'deceptive';
      feedbackEmoji = '🚨 '; // Alarm emoji for incorrect
    } else {
      feedbackText = `Correct ${groundTruth}`;
      feedbackClass = 'deceptive';
      feedbackEmoji = '👮 '; // Police officer emoji for correct
    }
  }
  
  // Remove any existing feedback text
  const existingFeedback = document.querySelector('.feedback-text');
  if (existingFeedback) {
    existingFeedback.remove();
  }
  
  // Add new feedback text with emoji
  const feedbackDiv = document.createElement('div');
  feedbackDiv.className = `feedback-text ${feedbackClass}`;
  // Add emoji to both sides of the text
  feedbackDiv.textContent = `${feedbackEmoji}${feedbackText}${feedbackEmoji}`;
  classificationButtons.parentNode.insertBefore(feedbackDiv, classificationButtons.nextSibling);
}
</script>
</body>
</html>